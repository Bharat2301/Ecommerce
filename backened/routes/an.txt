i have backened folder in that i have controllers folder in that i have authController.ts file
import { Response } from 'express';
import prisma from '../prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import sanitizeHtml from 'sanitize-html';
import { validateEmail, validatePassword, validateName } from '../utils/validation';
import { validateOtp, generateOtp, saveOTP } from '../utils/otpUtils';
import { AsyncRequestHandler, AuthRequest } from '../types/custom';
import { ValidationError, AuthenticationError, NotFoundError, AppError } from '../utils/errorHandler';
import { logger } from '../utils/logger';
import { sendVerificationEmail } from '../utils/emailUtils';
import { rateLimit } from 'express-rate-limit';
// Remove import since sanitizeInput is defined locally in this file

// Validate environment variables
const requiredEnvVars = ['JWT_SECRET', 'OTP_EXPIRY_MINUTES', 'RESEND_API_KEY', 'RESEND_FROM_EMAIL'];
for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    logger.error(`Missing environment variable: ${envVar}`);
    throw new Error(`Missing environment variable: ${envVar}`);
  }
}

const userRegistrationSchema = z.object({
  email: z.string().refine(validateEmail, { message: 'Invalid email format' }),
  password: z.string().refine(validatePassword, {
    message: 'Password must be at least 8 characters, including uppercase, lowercase, number, and special character',
  }),
  name: z.string().refine(validateName, { message: 'Name must be 2-50 characters, letters only' }),
  securityQuestions: z
    .array(
      z.object({
        question: z.string().min(1, { message: 'Security question is required' }),
        answer: z.string().min(1, { message: 'Security answer is required' }),
      })
    )
    .length(2, { message: 'Exactly two security questions are required' }),
});

const loginSchema = z.object({
  email: z.string().refine(validateEmail, { message: 'Invalid email format' }),
  password: z.string().min(1, { message: 'Password is required' }),
});

const resetPasswordSchema = z.object({
  email: z.string().refine(validateEmail, { message: 'Invalid email format' }),
  otp: z.string().length(6, { message: 'OTP must be 6 digits' }),
  newPassword: z.string().refine(validatePassword, {
    message: 'Password must be at least 8 characters, including uppercase, lowercase, number, and special character',
  }),
});

const requestOtpSchema = z.object({
  email: z.string().refine(validateEmail, { message: 'Invalid email format' }),
});

const verifyEmailSchema = z.object({
  token: z.string().min(1, { message: 'Verification token is required' }),
});

// Sanitize inputs to prevent XSS
const sanitizeInput = (input: string): string => sanitizeHtml(input, {
  allowedTags: [],
  allowedAttributes: {},
});

export const register: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = uuidv4();
  try {
    const { email, password, name, securityQuestions } = registerSchema.parse({
      ...req.body,
      email: sanitizeInput(req.body.email),
      name: sanitizeInput(req.body.name),
      securityQuestions: req.body.securityQuestions?.map((q: any) => ({
        question: sanitizeInput(q.question),
        answer: sanitizeInput(q.answer),
      })),
    });

    const existingUser = await prisma.user.findUnique({
      where: { email },
      select: { id: true },
    });
    if (existingUser) {
      logger.warn(`[${requestId}] Email already registered`, { email });
      throw new ValidationError('Email already registered');
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const verificationToken = uuidv4();

    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name,
        role: 'user',
        isVerified: false,
        verificationToken,
        securityQuestions: {
          create: securityQuestions.map(({ question, answer }) => ({
            question,
            answer,
          })),
        },
      },
      select: { id: true, email: true, role: true, name: true },
    });

    // Send verification email
    await sendVerificationEmail(email, verificationToken);

    logger.info(`[${requestId}] User registered successfully`, { email, userId: user.id });
    return res.status(201).json({
      success: true,
      data: { user: { id: user.id, email: user.email, role: user.role, name: user.name } },
      message: 'Registration successful. Please verify your email.',
      requestId,
    });
  } catch (error: any) {
    logger.error(`[${requestId}] Register error`, {
      message: error.message,
      stack: error.stack,
      email: req.body.email,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

// Add rate limiting for auth endpoints
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts
  message: { success: false, error: 'Too many attempts. Please try again later.' }
});

// Add password complexity validation
const passwordStrengthRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

// Remove this duplicate schema definition
const registerSchema = z.object({
  email: z.string().email('Invalid email format').toLowerCase(),
  password: z.string().regex(
    passwordStrengthRegex,
    'Password must be at least 8 characters, include uppercase, lowercase, number, and special character'
  ),
  name: z.string().min(2, 'Name must be at least 2 characters').max(50, 'Name cannot exceed 50 characters'),
  securityQuestions: z.array(
    z.object({
      question: z.string().min(1, 'Security question is required'),
      answer: z.string().min(1, 'Security answer is required').transform(val => val.toLowerCase()),
    })
  ).length(2, 'Exactly two security questions are required'),
});

// Add session management
export const login: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = uuidv4();
  try {
    logger.info(`[${requestId}] Login attempt`, { email: req.body.email });
    const { email, password } = loginSchema.parse({
      ...req.body,
      email: sanitizeInput(req.body.email),
    });

    const user = await prisma.user.findUnique({
      where: { email },
      select: { id: true, email: true, role: true, name: true, password: true, isVerified: true },
    });
    if (!user) {
      logger.warn(`[${requestId}] User not found`, { email });
      throw new AuthenticationError('Invalid email or password');
    }

    if (!user.isVerified) {
      logger.warn(`[${requestId}] Email not verified`, { email });
      throw new AuthenticationError('Please verify your email before logging in');
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      logger.warn(`[${requestId}] Invalid password`, { email });
      throw new AuthenticationError('Invalid email or password');
    }

    // Generate access and refresh tokens
    const accessToken = jwt.sign(
      { id: user.id, email: user.email, role: user.role, name: user.name },
      process.env.JWT_SECRET!,
      { expiresIn: '1h' }
    );
    const refreshToken = jwt.sign(
      { id: user.id },
      process.env.JWT_SECRET!,
      { expiresIn: '30d' }
    );

    // Set HTTP-only cookies for both tokens
    res.cookie('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 60 * 60 * 1000, // 1 hour
    });
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    });

    logger.info(`[${requestId}] Login successful`, { email, userId: user.id });
    return res.json({
      success: true,
      data: { user: { id: user.id, email: user.email, role: user.role, name: user.name } },
      requestId,
    });
  } catch (error: any) {
    logger.error(`[${requestId}] Login error`, {
      message: error.message,
      stack: error.stack,
      email: req.body.email,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

export const logout: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = uuidv4();
  try {
    logger.info(`[${requestId}] Logout attempt`, { email: req.user?.email });
    const accessToken = req.cookies.accessToken;
    if (accessToken) {
      // Blacklist the access token
      await prisma.blacklistedToken.create({
        data: {
          token: accessToken,
          expiresAt: new Date(Date.now() + 60 * 60 * 1000), // Match access token expiry (1 hour)
        },
      });
    }

    // Clear both cookies
    res.clearCookie('accessToken', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });
    res.clearCookie('refreshToken', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });

    logger.info(`[${requestId}] Logout successful`, { email: req.user?.email });
    return res.json({ success: true, message: 'Logged out successfully', requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Logout error`, {
      message: error.message,
      stack: error.stack,
      userId: req.user?.id,
    });
    throw new AppError('Failed to logout', 500);
  }
};

export const resetPassword: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = uuidv4();
  try {
    const { email, otp, newPassword } = resetPasswordSchema.parse({
      ...req.body,
      email: sanitizeInput(req.body.email),
    });

    const isValidOtp = await validateOtp(email, otp);
    if (!isValidOtp) {
      logger.warn(`[${requestId}] Invalid or expired OTP`, { email });
      throw new ValidationError('Invalid or expired OTP');
    }

    const user = await prisma.user.findUnique({
      where: { email },
      select: { id: true },
    });
    if (!user) {
      logger.warn(`[${requestId}] User not found`, { email });
      throw new NotFoundError('User not found');
    }

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    await prisma.$transaction([
      prisma.user.update({
        where: { email },
        data: { password: hashedPassword },
      }),
      prisma.oTP.deleteMany({ where: { email } }),
    ]);

    logger.info(`[${requestId}] Password reset successful`, { email });
    return res.json({ success: true, message: 'Password reset successful', requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Reset password error`, {
      message: error.message,
      stack: error.stack,
      email: req.body.email,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

export const requestResetOtp: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = uuidv4();
  try {
    const { email } = requestOtpSchema.parse({
      ...req.body,
      email: sanitizeInput(req.body.email),
    });

    const user = await prisma.user.findUnique({
      where: { email },
      select: { id: true },
    });
    if (!user) {
      logger.warn(`[${requestId}] User not found`, { email });
      throw new NotFoundError('User not found');
    }

    const otp = await generateOtp();
    const otpExpiryMinutes = parseInt(process.env.OTP_EXPIRY_MINUTES || '5');
    await saveOTP(email, otp, otpExpiryMinutes);

    try {
      const response = await fetch('https://api.resend.com/emails', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${process.env.RESEND_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          from: process.env.RESEND_FROM_EMAIL,
          to: email,
          subject: 'Password Reset OTP',
          text: `Your OTP for password reset is ${otp}. It expires in ${otpExpiryMinutes} minutes.`,
        }),
      });

      if (!response.ok) {
        throw new Error(`Resend API error: ${response.statusText}`);
      }

      logger.info(`[${requestId}] OTP sent`, { email });
    } catch (emailError: any) {
      logger.error(`[${requestId}] Failed to send OTP email`, {
        message: emailError.message,
        email,
      });
      throw new AppError('Failed to send OTP email', 500);
    }

    return res.json({ success: true, message: 'OTP sent to email', requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Request reset OTP error`, {
      message: error.message,
      email: req.body.email,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

export const verifyEmail: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = uuidv4();
  try {
    const { token } = verifyEmailSchema.parse(req.body);

    const user = await prisma.user.findFirst({
      where: { verificationToken: token },
      select: { id: true, email: true, role: true, name: true },
    });

    if (!user) {
      logger.warn(`[${requestId}] Invalid or expired verification token`, { token });
      throw new ValidationError('Invalid or expired verification token');
    }

    await prisma.user.update({
      where: { id: user.id },
      data: {
        isVerified: true,
        verificationToken: null,
      },
    });

    logger.info(`[${requestId}] Email verified successfully`, { email: user.email });
    return res.json({
      success: true,
      message: 'Email verified successfully',
      data: { user: { id: user.id, email: user.email, role: user.role, name: user.name } },
      requestId,
    });
  } catch (error: any) {
    logger.error(`[${requestId}] Verify email error`, {
      message: error.message,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

// Add account lockout after failed attempts
export const loginAttemptTracker = new Map<string, { attempts: number, lastAttempt: number }>();

const MAX_LOGIN_ATTEMPTS = 5;
const LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes

function checkLoginAttempts(email: string): boolean {
  const tracker = loginAttemptTracker.get(email);
  if (!tracker) return true;

  if (Date.now() - tracker.lastAttempt > LOCKOUT_DURATION) {
    loginAttemptTracker.delete(email);
    return true;
  }

  return tracker.attempts < MAX_LOGIN_ATTEMPTS;
}
then i have cartController.ts file
import { Response } from 'express';
import { AsyncRequestHandler, AuthRequest } from '../types/custom';
import prisma from '../prisma/client';
import { z } from 'zod';

interface CartItemInput {
  productId: string;
  quantity: number;
  price: number;
  size?: string;
  name?: string;
  image?: string;
}

const cartItemSchema = z.object({
  productId: z.string().min(1, 'Product ID is required'),
  quantity: z.number().int().min(1, 'Quantity must be at least 1'),
  price: z.number().positive('Price must be positive'),
  size: z.string().optional(),
  name: z.string().optional(),
  image: z.string().optional(),
});

const syncCartSchema = z.object({
  cartItems: z.array(cartItemSchema),
});

// Helper function to delete cart and clear User.cartId
const deleteCart = async (cartId: string, userId: string): Promise<void> => {
  await prisma.$transaction([
    prisma.cartItem.deleteMany({ where: { cartId } }),
    prisma.cart.delete({ where: { id: cartId } }),
    prisma.user.update({
      where: { id: userId },
      data: { cartId: null },
    }),
  ]);
};

// Get user's cart
export const getCart: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      console.error('User not authenticated for getCart');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const cart = await prisma.cart.findFirst({
      where: { userId },
      include: { items: { include: { product: true } } },
    });

    if (!cart) {
      return res.json({ success: true, data: { cartItems: [], total: 0 } });
    }

    const cartItems = cart.items.map((item) => ({
      productId: item.productId,
      quantity: item.quantity,
      price: item.price,
      size: item.size,
      name: item.product.name,
      image: item.product.images[0] || 'https://via.placeholder.com/80',
    }));

    const total = Number(cartItems.reduce((sum, item) => sum + item.price * item.quantity, 0).toFixed(2));
    console.log(`Fetched cart for user ${userId}:`, { cartItems, total });
    return res.json({ success: true, data: { cartItems, total } });
  } catch (err: any) {
    console.error('Get cart error:', {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
    });
    return res.status(500).json({ success: false, error: 'Failed to fetch cart' });
  }
};

// Sync client and server cart
export const syncCart: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      console.error('User not authenticated for syncCart');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const { cartItems } = syncCartSchema.parse(req.body);

    // Fetch products in bulk
    const productIds = cartItems.map((item) => item.productId);
    const products = await prisma.product.findMany({
      where: { id: { in: productIds } },
    });

    const productMap = new Map(products.map((p) => [p.id, p]));

    // Validate client cart items
    const validatedItems: CartItemInput[] = [];
    for (const item of cartItems) {
      const product = productMap.get(item.productId);
      if (!product) {
        console.error(`Product not found: ${item.productId}`);
        return res.status(404).json({ success: false, error: `Product ${item.productId} not found` });
      }

      if (Math.abs(item.price - product.price) > 0.01) {
        console.error(`Price mismatch for ${product.name}: expected ₹${product.price}, got ₹${item.price}`);
        return res.status(400).json({
          success: false,
          error: `Price mismatch for product ${product.name}: expected ₹${product.price}, got ₹${item.price}`,
        });
      }

      const stockBySize = (product.stockBySize as Record<string, number> | undefined) || {};
      const size = item.size || 'default';
      if (product.sizes?.length && !item.size) {
        console.error(`Size required for product: ${product.name}`);
        return res.status(400).json({ success: false, error: `Size is required for ${product.name}` });
      }
      if (!stockBySize[size] || stockBySize[size] < item.quantity) {
        console.error(`Insufficient stock for ${product.name} in size ${size}`);
        return res.status(400).json({ success: false, error: `Insufficient stock for ${product.name} in size ${size}` });
      }

      validatedItems.push({
        productId: item.productId,
        quantity: item.quantity,
        price: product.price,
        size: item.size,
        name: product.name,
        image: product.images[0] || 'https://via.placeholder.com/80',
      });
    }

    // Get or create server cart
    let cart = await prisma.cart.findFirst({ where: { userId } });
    if (!cart) {
      cart = await prisma.cart.create({
        data: { userId },
      });
      await prisma.user.update({
        where: { id: userId },
        data: { cartId: cart.id },
      });
    }

    // Clear existing cart items
    await prisma.cartItem.deleteMany({ where: { cartId: cart.id } });

    // Insert validated items
    await prisma.cartItem.createMany({
      data: validatedItems.map((item) => ({
        cartId: cart.id,
        productId: item.productId,
        quantity: item.quantity,
        price: item.price,
        size: item.size || null,
      })),
    });

    const total = Number(validatedItems.reduce((sum, item) => sum + item.price * item.quantity, 0).toFixed(2));
    console.log(`Synced cart for user ${userId}:`, { cartItems: validatedItems, total });
    return res.json({ success: true, data: { cartItems: validatedItems, total } });
  } catch (err: any) {
    console.error('Sync cart error:', {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: err instanceof z.ZodError ? err.errors.map((e) => e.message).join(', ') : 'Failed to sync cart',
    });
  }
};

// Add item to cart
export const addToCart: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const { productId, quantity, price, size } = cartItemSchema.parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      console.error('User not authenticated for addToCart');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const product = await prisma.product.findUnique({ where: { id: productId } });
    if (!product) {
      console.error(`Product not found: ${productId}`);
      return res.status(404).json({ success: false, error: 'Product not found' });
    }

    if (Math.abs(product.price - price) > 0.01) {
      console.error(`Price mismatch for ${product.name}: expected ₹${product.price}, got ₹${price}`);
      return res.status(400).json({
        success: false,
        error: `Price mismatch for product ${product.name}: expected ₹${product.price}, got ₹${price}`,
      });
    }

    const stockBySize = (product.stockBySize as Record<string, number> | undefined) || {};
    const selectedSize = size || 'default';
    if (product.sizes?.length && !size) {
      console.error(`Size required for product: ${product.name}`);
      return res.status(400).json({ success: false, error: 'Size is required' });
    }
    if (!stockBySize[selectedSize] || stockBySize[selectedSize] < quantity) {
      console.error(`Insufficient stock for ${product.name} in size ${selectedSize}`);
      return res.status(400).json({ success: false, error: `Insufficient stock for size ${selectedSize}` });
    }

    let cart = await prisma.cart.findFirst({ where: { userId } });
    if (!cart) {
      cart = await prisma.cart.create({
        data: { userId },
      });
      await prisma.user.update({
        where: { id: userId },
        data: { cartId: cart.id },
      });
    }

    const existingItem = await prisma.cartItem.findFirst({
      where: { cartId: cart.id, productId, size: size || null },
    });

    if (existingItem) {
      await prisma.cartItem.update({
        where: { id: existingItem.id },
        data: { quantity: existingItem.quantity + quantity },
      });
    } else {
      await prisma.cartItem.create({
        data: {
          cartId: cart.id,
          productId,
          quantity,
          price: product.price,
          size: size || null,
        },
      });
    }

    console.log(`Added item to cart for user ${userId}:`, { productId, quantity, size });
    return res.json({ success: true, message: 'Item added to cart' });
  } catch (err: any) {
    console.error('Add to cart error:', {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: err instanceof z.ZodError ? err.errors.map((e) => e.message).join(', ') : 'Failed to add item to cart',
    });
  }
};

// Update cart item
export const updateCartItem: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const { productId, quantity, size } = cartItemSchema.parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      console.error('User not authenticated for updateCartItem');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const cart = await prisma.cart.findFirst({ where: { userId } });
    if (!cart) {
      console.error(`Cart not found for user ${userId}`);
      return res.status(404).json({ success: false, error: 'Cart not found' });
    }

    const item = await prisma.cartItem.findFirst({
      where: { cartId: cart.id, productId, size: size || null },
    });
    if (!item) {
      console.error(`Cart item not found: ${productId}, size: ${size}`);
      return res.status(404).json({ success: false, error: 'Item not found in cart' });
    }

    const product = await prisma.product.findUnique({ where: { id: productId } });
    if (!product) {
      console.error(`Product not found: ${productId}`);
      return res.status(404).json({ success: false, error: 'Product not found' });
    }

    const stockBySize = (product.stockBySize as Record<string, number> | undefined) || {};
    const selectedSize = size || 'default';
    if (!stockBySize[selectedSize] || stockBySize[selectedSize] < quantity) {
      console.error(`Insufficient stock for ${product.name} in size ${selectedSize}`);
      return res.status(400).json({ success: false, error: `Insufficient stock for size ${selectedSize}` });
    }

    if (quantity === 0) {
      await prisma.cartItem.delete({ where: { id: item.id } });
    } else {
      await prisma.cartItem.update({
        where: { id: item.id },
        data: { quantity },
      });
    }

    console.log(`Updated cart item for user ${userId}:`, { productId, quantity, size });
    return res.json({ success: true, message: 'Cart item updated' });
  } catch (err: any) {
    console.error('Update cart item error:', {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: err instanceof z.ZodError ? err.errors.map((e) => e.message).join(', ') : 'Failed to update cart item',
    });
  }
};

// Remove cart item
export const removeCartItem: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const { productId, size } = z
      .object({
        productId: z.string().min(1, 'Product ID is required'),
        size: z.string().optional(),
      })
      .parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      console.error('User not authenticated for removeCartItem');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const cart = await prisma.cart.findFirst({ where: { userId } });
    if (!cart) {
      console.error(`Cart not found for user ${userId}`);
      return res.status(404).json({ success: false, error: 'Cart not found' });
    }

    const item = await prisma.cartItem.findFirst({
      where: { cartId: cart.id, productId, size: size || null },
    });
    if (!item) {
      console.error(`Cart item not found: ${productId}, size: ${size}`);
      return res.status(404).json({ success: false, error: 'Item not found in cart' });
    }

    await prisma.cartItem.delete({ where: { id: item.id } });
    console.log(`Removed cart item for user ${userId}:`, { productId, size });
    return res.json({ success: true, message: 'Item removed from cart' });
  } catch (err: any) {
    console.error('Remove cart item error:', {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: err instanceof z.ZodError ? err.errors.map((e) => e.message).join(', ') : 'Failed to remove cart item',
    });
  }
};

// Clear cart
export const clearCart: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      console.error('User not authenticated for clearCart');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const cart = await prisma.cart.findFirst({ where: { userId } });
    if (!cart) {
      console.log(`No cart found for user ${userId}, returning empty`);
      return res.json({ success: true, message: 'Cart is already empty' });
    }

    await deleteCart(cart.id, userId);
    console.log(`Cleared cart for user ${userId}`);
    return res.json({ success: true, message: 'Cart cleared' });
  } catch (err: any) {
    console.error('Clear cart error:', {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
    });
    return res.status(500).json({ success: false, error: 'Failed to clear cart' });
  }
};

// Validate cart
export const validateCart: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const { items, offerCode } = z
      .object({
        items: z.array(cartItemSchema),
        offerCode: z.string().optional(),
      })
      .parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      console.error('User not authenticated for validateCart');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    if (!items || items.length === 0) {
      console.error('Invalid cart items:', items);
      return res.status(400).json({ success: false, error: 'Cart items are required' });
    }

    const productIds = items.map((item) => item.productId);
    const products = await prisma.product.findMany({
      where: { id: { in: productIds } },
    });

    const productMap = new Map(products.map((p) => [p.id, p]));
    let calculatedTotal = 0;
    const validatedItems: CartItemInput[] = [];

    for (const item of items) {
      const product = productMap.get(item.productId);
      if (!product) {
        console.error(`Product not found: ${item.productId}`);
        return res.status(404).json({ success: false, error: `Product ${item.productId} not found` });
      }

      if (Math.abs(item.price - product.price) > 0.01) {
        console.error(`Price mismatch for ${product.name}: expected ₹${product.price}, got ₹${item.price}`);
        return res.status(400).json({
          success: false,
          error: `Price mismatch for product ${product.name}: expected ₹${product.price}, got ₹${item.price}`,
        });
      }

      const stockBySize = (product.stockBySize as Record<string, number> | undefined) || {};
      const size = item.size || 'default';
      if (product.sizes?.length && !item.size) {
        console.error(`Size selection required for ${product.name}`);
        return res.status(400).json({ success: false, error: `Size selection required for ${product.name}` });
      }
      if (!stockBySize[size] || stockBySize[size] < item.quantity) {
        console.error(`Insufficient stock for ${product.name} in size ${size}`);
        return res.status(400).json({ success: false, error: `Insufficient stock for ${product.name} in size ${size}` });
      }

      calculatedTotal += product.price * item.quantity;
      validatedItems.push({
        productId: item.productId,
        quantity: item.quantity,
        price: product.price,
        size: item.size,
        name: product.name,
        image: product.images[0] || 'https://via.placeholder.com/80',
      });
    }

    calculatedTotal = Number(calculatedTotal.toFixed(2));
    let discount = 0;
    let discountedTotal = calculatedTotal;

    if (offerCode) {
      const offer = await prisma.offerCode.findUnique({ where: { code: offerCode.toUpperCase() } });
      if (!offer) {
        console.error(`Invalid offer code: ${offerCode}`);
        return res.status(400).json({ success: false, error: `Invalid offer code` });
      }
      if (offer.expiryDate && offer.expiryDate < new Date()) {
        console.error(`Expired offer code: ${offerCode}`);
        return res.status(400).json({ success: false, error: `Offer code has expired` });
      }
      const userOffer = await prisma.userOfferCode.findFirst({
        where: { userId, offerCodeId: offer.id },
      });
      if (userOffer) {
        console.error(`Offer code already used: ${offerCode}`);
        return res.status(400).json({ success: false, error: `This code was already used` });
      }
      if (offer.isFirstOrder) {
        const orderCount = await prisma.order.count({ where: { userId } });
        if (orderCount > 0) {
          console.error(`First-order offer code not applicable: ${offerCode}`);
          return res.status(400).json({ success: false, error: `Offer code is only for first orders` });
        }
      }
      discount = offer.discount;
      discountedTotal = Number((calculatedTotal * (1 - discount / 100)).toFixed(2));
    }

    console.log('Cart validated successfully:', {
      userId,
      items: validatedItems,
      calculatedTotal,
      discount,
      discountedTotal,
      offerCode,
    });
    return res.json({ success: true, data: { valid: true, total: discountedTotal, items: validatedItems, discount } });
  } catch (err: any) {
    console.error('Validate cart error:', {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: err instanceof z.ZodError ? err.errors.map((e) => e.message).join(', ') : 'Failed to validate cart',
    });
  }
};
then i have offerCode.controller.ts file
import { Response } from 'express';
import { AsyncRequestHandler, AuthRequest } from '../types/custom';
import prisma from '../prisma/client';
import { z } from 'zod';

const applyOfferCodeSchema = z.object({
  code: z.string().min(1, 'Offer code is required'),
  cartTotal: z.number().positive('Cart total must be positive'),
  items: z.array(
    z.object({
      productId: z.string().min(1, 'Product ID is required'),
      quantity: z.number().int().min(1, 'Quantity must be at least 1'),
      price: z.number().positive('Price must be positive'),
      size: z.string().optional(),
    })
  ),
});

export const applyOfferCode: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const { code, cartTotal, items } = applyOfferCodeSchema.parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      console.error('User not authenticated for applyOfferCode');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    if (!items || items.length === 0) {
      console.error('No cart items provided');
      return res.status(400).json({ success: false, error: 'Cart items are required' });
    }

    // Validate cart items
    const productIds = items.map((item) => item.productId);
    const products = await prisma.product.findMany({
      where: { id: { in: productIds } },
    });

    const productMap = new Map(products.map((p) => [p.id, p]));
    let calculatedTotal = 0;

    for (const item of items) {
      const product = productMap.get(item.productId);
      if (!product) {
        console.error(`Product not found: ${item.productId}`);
        return res.status(404).json({ success: false, error: `Product not found` });
      }

      if (Math.abs(item.price - product.price) > 0.01) {
        console.error(`Price mismatch for ${product.name}: expected ₹${product.price}, got ₹${item.price}`);
        return res.status(400).json({
          success: false,
          error: `Price mismatch for product ${product.name}: expected ₹${product.price}, got ₹${item.price}`,
        });
      }

      const stockBySize = (product.stockBySize as Record<string, number> | undefined) || {};
      const size = item.size || 'default';
      if (product.sizes?.length && !item.size) {
        console.error(`Size required for product: ${product.name}`);
        return res.status(400).json({ success: false, error: `Size is required for ${product.name}` });
      }
      if (!stockBySize[size] || stockBySize[size] < item.quantity) {
        console.error(`Insufficient stock for ${product.name} in size ${size}`);
        return res.status(400).json({ success: false, error: `Insufficient stock for ${product.name} in size ${size}` });
      }

      calculatedTotal += item.price * item.quantity;
    }

    calculatedTotal = Number(calculatedTotal.toFixed(2));
    if (Math.abs(calculatedTotal - cartTotal) > 0.01) {
      console.error(`Cart total mismatch: expected ₹${calculatedTotal}, got ₹${cartTotal}`);
      return res.status(400).json({
        success: false,
        error: `Cart total mismatch: expected ₹${calculatedTotal}, got ₹${cartTotal}`,
      });
    }

    // Validate and apply offer code
    const offerCode = await prisma.offerCode.findUnique({ where: { code: code.toUpperCase() } });
    if (!offerCode) {
      console.error(`Invalid offer code: ${code}`);
      return res.status(400).json({ success: false, error: `Invalid offer code` });
    }

    if (offerCode.expiryDate && offerCode.expiryDate < new Date()) {
      console.error(`Expired offer code: ${code}`);
      return res.status(400).json({ success: false, error: `Offer code has expired` });
    }

    const codeUsed = await prisma.userOfferCode.findFirst({
      where: { userId, offerCodeId: offerCode.id },
    });
    if (codeUsed) {
      console.error(`Offer code already used: ${code}`);
      return res.status(400).json({ success: false, error: `This code was already used` });
    }

    const userOrderCount = await prisma.order.count({ where: { userId } });
    if (offerCode.isFirstOrder && userOrderCount > 0) {
      console.error(`First-order offer code not applicable: ${code}`);
      return res.status(400).json({ success: false, error: `Offer code is only for first orders` });
    }

    if (offerCode.discount < 0 || offerCode.discount > 100) {
      console.error(`Invalid discount value: ${offerCode.discount}% for code ${code}`);
      return res.status(400).json({ success: false, error: `Invalid discount value` });
    }

    // Apply offer code in a transaction
    await prisma.$transaction([
      prisma.userOfferCode.create({
        data: {
          userId,
          offerCodeId: offerCode.id,
        },
      }),
    ]);

    const discountedTotal = Number((calculatedTotal * (1 - offerCode.discount / 100)).toFixed(2));

    console.log(`Applied offer code for user ${userId}:`, {
      code,
      discount: offerCode.discount,
      cartTotal,
      discountedTotal,
    });
    return res.json({
      success: true,
      data: {
        code: offerCode.code,
        discount: offerCode.discount,
        discountedTotal,
      },
    });
  } catch (error: any) {
    console.error('Apply offer code error:', {
      message: error.message,
      stack: error.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: error instanceof z.ZodError ? error.errors.map((e) => e.message).join(', ') : 'Failed to apply offer code',
    });
  }
};
then i have orderController.ts file
import { Response } from 'express';
import { AsyncRequestHandler, AuthRequest } from '../types/custom';
import prisma from '../prisma/client';
import { createShiprocketOrder, getTrackingInfo } from '../utils/shiprocket';
import { z } from 'zod';

interface OrderItemInput {
  productId: string;
  quantity: number;
  price: number;
  size?: string;
}

interface ShippingDetails {
  name: string;
  address: string;
  city: string;
  pincode: string;
  phone: string;
  state?: string;
}

const confirmOrderSchema = z.object({
  dbOrderId: z.string().min(1, 'Order ID is required'),
  paymentId: z.string().min(1, 'Payment ID is required'),
});

// Zod schema for validating shippingDetails
const shippingDetailsSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  address: z.string().min(1, 'Address is required'),
  city: z.string().min(1, 'City is required'),
  pincode: z.string().min(1, 'Pincode is required'),
  phone: z.string().min(1, 'Phone is required'),
  state: z.string().optional(),
});

export const confirmOrder: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const { dbOrderId, paymentId } = confirmOrderSchema.parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      console.error('User not authenticated for confirmOrder');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const order = await prisma.order.findUnique({
      where: { id: dbOrderId },
      include: {
        user: true,
        orderItems: {
          include: {
            product: true,
          },
        },
      },
    });

    if (!order) {
      console.error(`Order not found: ${dbOrderId}`);
      return res.status(404).json({ success: false, error: 'Order not found' });
    }

    if (order.userId !== userId) {
      console.error(`Unauthorized access to order ${dbOrderId} by user ${userId}`);
      return res.status(403).json({ success: false, error: 'Not authorized to confirm this order' });
    }

    if (!order.shippingDetails) {
      console.error(`Shipping details missing for order ${dbOrderId}`);
      return res.status(400).json({ success: false, error: 'Shipping details are required' });
    }

    // Validate shippingDetails using Zod
    let shippingDetails: ShippingDetails;
    try {
      shippingDetails = shippingDetailsSchema.parse(order.shippingDetails);
    } catch (error) {
      console.error(`Invalid shipping details for order ${dbOrderId}:`, error);
      return res.status(400).json({ success: false, error: 'Invalid shipping details format' });
    }

    // Validate and update stock
    const stockUpdates = [];
    for (const item of order.orderItems) {
      const product = await prisma.product.findUnique({ where: { id: item.productId } });
      if (!product) {
        console.error(`Product not found: ${item.productId}`);
        return res.status(404).json({ success: false, error: `Product not found` });
      }

      const stockBySize = (product.stockBySize as Record<string, number>) || {};
      const size = item.size || 'default';
      if (product.sizes?.length && !item.size) {
        console.error(`Size required for product: ${product.name}`);
        return res.status(400).json({ success: false, error: `Size is required for ${product.name}` });
      }
      if (!stockBySize[size] || stockBySize[size] < item.quantity) {
        console.error(`Insufficient stock for ${product.name} in size ${size}`);
        return res.status(400).json({ success: false, error: `Insufficient stock for ${product.name} in size ${size}` });
      }

      stockBySize[size] -= item.quantity;
      const totalStock = Object.values(stockBySize).reduce((sum: number, val: number) => sum + val, 0);

      stockUpdates.push(
        prisma.product.update({
          where: { id: item.productId },
          data: {
            quantity: totalStock,
            stockBySize,
            orderCount: { increment: item.quantity },
          },
        })
      );
    }

    const productItems = order.orderItems.map((item) => ({
      name: item.product.name,
      sku: `SKU_${item.productId}`,
      units: item.quantity,
      selling_price: item.price,
    }));

    if (productItems.length === 0) {
      console.error(`No products found in order ${dbOrderId}`);
      return res.status(400).json({ success: false, error: 'No products found in the order' });
    }

    const shiprocketData = {
      order_id: dbOrderId,
      order_date: new Date().toISOString(),
      pickup_location: 'Primary',
      billing_customer_name: shippingDetails.name,
      billing_last_name: '',
      billing_address: shippingDetails.address,
      billing_city: shippingDetails.city,
      billing_pincode: shippingDetails.pincode,
      billing_state: shippingDetails.state || '',
      billing_country: 'India',
      billing_phone: shippingDetails.phone,
      shipping_is_billing: true,
      order_items: productItems,
      payment_method: 'Prepaid',
      sub_total: order.totalAmount,
      length: 10,
      breadth: 10,
      height: 10,
      weight: 0.5,
    };

    const shiprocketResponse = await createShiprocketOrder(shiprocketData);

    await prisma.$transaction([
      ...stockUpdates,
      prisma.order.update({
        where: { id: dbOrderId },
        data: {
          status: 'confirmed',
          paymentId,
          shiprocketOrderId: shiprocketResponse.order_id,
          trackingUrl: shiprocketResponse.tracking_url || '',
        },
      }),
      // Clear cart
      prisma.cartItem.deleteMany({ where: { cart: { userId } } }),
      prisma.cart.deleteMany({ where: { userId } }),
      prisma.user.update({
        where: { id: userId },
        data: { cartId: null },
      }),
    ]);

    console.log(`Confirmed order ${dbOrderId} for user ${userId}:`, { shiprocketOrderId: shiprocketResponse.order_id });
    return res.json({
      success: true,
      data: { orderId: dbOrderId, shiprocketOrderId: shiprocketResponse.order_id },
    });
  } catch (error: any) {
    console.error('Confirm order error:', {
      message: error.message,
      stack: error.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: error.message || 'Failed to confirm order',
    });
  }
};

export const getOrderTracking: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    const { orderId } = z.object({ orderId: z.string().min(1) }).parse(req.params);
    const userId = req.user?.id;

    if (!userId) {
      console.error('User not authenticated for getOrderTracking');
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }

    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: { user: true },
    });

    if (!order) {
      console.error(`Order not found: ${orderId}`); // Fixed typo: removed "andria"
      return res.status(404).json({ success: false, error: 'Order not found' });
    }

    if (order.userId !== userId) {
      console.error(`Unauthorized access to order ${orderId} by user ${userId}`);
      return res.status(403).json({ success: false, error: 'Not authorized to track this order' });
    }

    if (!order.shiprocketOrderId) {
      console.error(`Tracking not available for order ${orderId}`);
      return res.status(404).json({ success: false, error: 'Tracking not available' });
    }

    const trackingInfo = await getTrackingInfo(order.shiprocketOrderId);
    console.log(`Fetched tracking for order ${orderId}:`, trackingInfo);
    return res.json({ success: true, data: { order, tracking: trackingInfo } });
  } catch (error: any) {
    console.error('Get tracking info error:', {
      message: error.message,
      stack: error.stack,
      userId: req.user?.id,
    });
    return res.status(500).json({
      success: false,
      error: error.message || 'Failed to fetch tracking info',
    });
  }
};

export const getAllOrders: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  try {
    if (!req.user || req.user.role !== 'admin') {
      console.error('Admin access required for getAllOrders', { userId: req.user?.id });
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    const orders = await prisma.order.findMany({
      include: {
        user: true,
        orderItems: {
          include: {
            product: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    console.log(`Fetched ${orders.length} orders for admin`);
    return res.status(200).json({ success: true, data: orders });
  } catch (error: any) {
    console.error('Fetch orders error:', {
      message: error.message,
      stack: error.stack,
      userId: req.user?.id,
    });
    return res.status(500).json({
      success: false,
      error: error.message || 'Failed to fetch orders',
    });
  }
};
then i have paymentController.ts file
// backend/controllers/paymentController.ts
import { Response } from 'express';
import { AsyncRequestHandler, AuthRequest } from '../types/custom';
import Razorpay from 'razorpay';
import prisma from '../prisma/client';
import { z } from 'zod';
import crypto from 'crypto';
import { confirmOrder } from './orderController';
import sanitizeHtml from 'sanitize-html';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../utils/logger';

const razorpay = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID!,
  key_secret: process.env.RAZORPAY_KEY_SECRET!,
});

interface OrderItemInput {
  productId: string;
  quantity: number;
  price: number;
  size?: string;
}

interface ItemDetail {
  productId: string;
  name: string;
  price: number;
  quantity: number;
  size?: string;
}

interface ShippingDetails {
  name: string;
  email: string;
  phone: string;
  address: string;
  pincode: string;
  city: string;
  state?: string;
}

const createOrderSchema = z.object({
  amount: z.number().positive('Amount must be positive'),
  currency: z.literal('INR', { errorMap: () => ({ message: 'Currency must be INR' }) }),
  items: z.array(
    z.object({
      productId: z.string().min(1, 'Product ID is required'),
      quantity: z.number().int().min(1, 'Quantity must be at least 1'),
      price: z.number().positive('Price must be positive'),
      size: z.string().optional(),
    })
  ).min(1, 'At least one item is required'),
  discount: z.number().min(0, 'Discount cannot be negative').default(0),
  offerCode: z.string().optional().nullable(),
  shippingDetails: z.object({
    name: z.string().min(1, 'Name is required'),
    email: z.string().email('Invalid email'),
    phone: z.string().regex(/^\d{10}$/, 'Phone must be 10 digits'),
    address: z.string().min(1, 'Address is required'),
    pincode: z.string().regex(/^\d{6}$/, 'Pincode must be 6 digits'),
    city: z.string().min(1, 'City is required'),
    state: z.string().optional(),
  }),
});

const verifyPaymentSchema = z.object({
  orderId: z.string().min(1, 'Razorpay order ID is required'),
  paymentId: z.string().min(1, 'Payment ID is required'),
  signature: z.string().min(1, 'Signature is required'),
  dbOrderId: z.string().min(1, 'Database order ID is required'),
});

// Sanitize shipping details to prevent XSS
const sanitizeShippingDetails = (details: ShippingDetails): ShippingDetails => ({
  name: sanitizeHtml(details.name),
  email: sanitizeHtml(details.email),
  phone: sanitizeHtml(details.phone),
  address: sanitizeHtml(details.address),
  pincode: sanitizeHtml(details.pincode),
  city: sanitizeHtml(details.city),
  state: details.state ? sanitizeHtml(details.state) : undefined,
});

// Retry mechanism for Razorpay API calls
const withRetry = async <T>(operation: () => Promise<T>, maxRetries: number = 3): Promise<T> => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (axios.isAxiosError(error) && error.response?.status === 429 && attempt < maxRetries) {
        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
        logger.warn(`[${uuidv4()}] Rate limit hit, retrying in ${delay}ms... (Attempt ${attempt}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }
  throw new Error('Max retries reached');
};

// Validate cart consistency
const validateCartItems = async (userId: string, items: OrderItemInput[]): Promise<boolean> => {
  const cart = await prisma.cart.findFirst({
    where: { userId },
    include: { items: true },
  });

  if (!cart) return false;

  const cartItemsMap = new Map(cart.items.map(item => [`${item.productId}-${item.size || 'default'}`, item]));
  for (const item of items) {
    const key = `${item.productId}-${item.size || 'default'}`;
    const cartItem = cartItemsMap.get(key);
    if (!cartItem || cartItem.quantity < item.quantity || Math.abs(cartItem.price - item.price) > 0.01) {
      return false;
    }
  }
  return true;
};

export const createOrder: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  const requestId = uuidv4();
  try {
    const { amount, currency, items, discount, offerCode, shippingDetails } = createOrderSchema.parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      logger.error(`[${requestId}] User not authenticated for createOrder`, { requestBody: req.body });
      return res.status(401).json({ success: false, error: 'User not authenticated', requestId });
    }

    // Validate cart consistency
    const isCartValid = await validateCartItems(userId, items);
    if (!isCartValid) {
      logger.error(`[${requestId}] Cart items do not match server cart`, { userId, items });
      return res.status(400).json({ success: false, error: 'Cart items do not match server cart', requestId });
    }

    const sanitizedShippingDetails = sanitizeShippingDetails(shippingDetails);

    const productIds = items.map((item) => item.productId);
    const products = await prisma.product.findMany({
      where: { id: { in: productIds } },
      select: {
        id: true,
        name: true,
        price: true,
        sizes: true,
        stockBySize: true,
        version: true,
      },
    });

    const productMap = new Map(products.map((p) => [p.id, p]));
    let calculatedTotal = 0;
    const itemDetails: ItemDetail[] = [];

    for (const item of items) {
      const product = productMap.get(item.productId);
      if (!product) {
        logger.error(`[${requestId}] Product not found: ${item.productId}`);
        return res.status(404).json({ success: false, error: `Product ${item.productId} not found`, requestId });
      }

      if (Math.abs(item.price - product.price) > 0.01) {
        logger.error(`[${requestId}] Price mismatch for ${product.name}: expected ₹${product.price}, got ₹${item.price}`);
        return res.status(400).json({
          success: false,
          error: `Price mismatch for product ${product.name}: expected ₹${product.price}, got ₹${item.price}`,
          requestId,
        });
      }

      const stockBySize = (product.stockBySize as Record<string, number> | undefined) || {};
      const size = item.size || 'default';
      if (product.sizes?.length && !item.size) {
        logger.error(`[${requestId}] Size required for product: ${product.name}`);
        return res.status(400).json({ success: false, error: `Size is required for ${product.name}`, requestId });
      }
      if (!stockBySize[size] || stockBySize[size] < item.quantity) {
        logger.error(`[${requestId}] Insufficient stock for ${product.name} in size ${size}`);
        return res.status(400).json({ success: false, error: `Insufficient stock for ${product.name} in size ${size}`, requestId });
      }

      calculatedTotal += item.price * item.quantity;
      itemDetails.push({ productId: item.productId, name: product.name, price: item.price, quantity: item.quantity, size });
    }

    calculatedTotal = Number(calculatedTotal.toFixed(2));
    let appliedDiscount = 0;

    if (offerCode) {
      const offer = await prisma.offerCode.findUnique({ 
        where: { code: offerCode.toUpperCase() },
        select: { id: true, discount: true, expiryDate: true, isFirstOrder: true }
      });
      if (!offer) {
        logger.error(`[${requestId}] Invalid offer code: ${offerCode}`);
        return res.status(400).json({ success: false, error: 'Invalid offer code', requestId });
      }

      if (offer.expiryDate && offer.expiryDate < new Date()) {
        logger.error(`[${requestId}] Expired offer code: ${offerCode}`);
        return res.status(400).json({ success: false, error: 'Offer code has expired', requestId });
      }

      const codeUsed = await prisma.userOfferCode.findFirst({
        where: { userId, offerCodeId: offer.id },
      });
      if (codeUsed) {
        logger.error(`[${requestId}] Offer code already used: ${offerCode}`);
        return res.status(400).json({ success: false, error: 'This offer code has already been used', requestId });
      }

      const userOrderCount = await prisma.order.count({ where: { userId } });
      if (offer.isFirstOrder && userOrderCount > 0) {
        logger.error(`[${requestId}] First-order offer code not applicable: ${offerCode}`);
        return res.status(400).json({ success: false, error: 'Offer code is only for first orders', requestId });
      }

      appliedDiscount = offer.discount;
      if (discount !== appliedDiscount) {
        logger.error(`[${requestId}] Discount mismatch: expected ${appliedDiscount}%, got ${discount}%`);
        return res.status(400).json({
          success: false,
          error: `Discount mismatch: expected ${appliedDiscount}%, got ${discount}%`,
          requestId,
        });
      }
    } else if (discount !== 0) {
      logger.error(`[${requestId}] Discount provided without an offer code`);
      return res.status(400).json({ success: false, error: 'Discount provided without an offer code', requestId });
    }

    const expectedAmount = Number((calculatedTotal * (1 - appliedDiscount / 100)).toFixed(2));
    if (Math.abs(expectedAmount - amount) > 0.01) {
      logger.error(`[${requestId}] Total amount mismatch: expected ₹${expectedAmount}, got ₹${amount}`);
      return res.status(400).json({
        success: false,
        error: `Total amount mismatch: expected ₹${expectedAmount}, got ₹${amount}`,
        details: {
          calculatedTotal,
          appliedDiscount,
          expectedAmount,
          receivedAmount: amount,
          items: itemDetails,
          offerCode,
        },
        requestId,
      });
    }

    const options = {
      amount: Math.round(amount * 100), // Convert rupees to paise for Razorpay
      currency,
      receipt: `receipt_order_${requestId}`,
    };

    const razorpayOrder = await withRetry(() => razorpay.orders.create(options));

    const order = await prisma.$transaction(async (tx) => {
      // Update stock within transaction
      for (const item of items) {
        const product = await tx.product.findUnique({
          where: { id: item.productId },
          select: { stockBySize: true, version: true },
        });
        if (!product) throw new Error(`Product ${item.productId} not found`);
        const stockBySize = (product.stockBySize as Record<string, number> | undefined) || {};
        const size = item.size || 'default';
        if (stockBySize[size] < item.quantity) {
          throw new Error(`Insufficient stock for ${item.productId} in size ${size}`);
        }
        stockBySize[size] -= item.quantity;
        await tx.product.update({
          where: { id: item.productId, version: product.version },
          data: { stockBySize, version: { increment: 1 } },
        });
      }

      const createdOrder = await tx.order.create({
        data: {
          userId,
          totalAmount: amount,
          status: 'pending',
          paymentId: razorpayOrder.id,
          offerCode: offerCode?.toUpperCase(),
          discount: appliedDiscount,
          shippingDetails: { ...sanitizedShippingDetails },
          orderItems: {
            create: items.map((item) => ({
              productId: item.productId,
              quantity: item.quantity,
              price: item.price,
              size: item.size,
            })),
          },
        },
      });

      if (offerCode) {
        const offer = await tx.offerCode.findUnique({ where: { code: offerCode.toUpperCase() } });
        if (offer) {
          await tx.userOfferCode.create({
            data: {
              userId,
              offerCodeId: offer.id,
            },
          });
        }
      }

      return createdOrder;
    });

    logger.info(`[${requestId}] Razorpay order created`, {
      orderId: razorpayOrder.id,
      dbOrderId: order.id,
      amount,
      userId,
    });
    return res.json({
      success: true,
      data: {
        orderId: razorpayOrder.id,
        dbOrderId: order.id,
        amount,
        currency,
        requestId,
      },
    });
  } catch (err: any) {
    logger.error(`[${requestId}] Create order error`, {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
      requestBody: {
        ...req.body,
        shippingDetails: req.body.shippingDetails
          ? { ...req.body.shippingDetails, email: '[REDACTED]', phone: '[REDACTED]' }
          : undefined,
      },
    });
    return res.status(500).json({
      success: false,
      error: err instanceof z.ZodError
        ? err.errors.map((e) => e.message).join(', ')
        : err.message.includes('Razorpay')
          ? 'Payment processing failed. Please try again later.'
          : 'Failed to create order',
      requestId,
    });
  }
};

export const verifyPayment: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  const requestId = uuidv4();
  try {
    const { orderId, paymentId, signature, dbOrderId } = verifyPaymentSchema.parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      logger.error(`[${requestId}] User not authenticated for verifyPayment`);
      return res.status(401).json({ success: false, error: 'User not authenticated', requestId });
    }

    // Verify Razorpay signature
    const generatedSignature = crypto
      .createHmac('sha256', process.env.RAZORPAY_KEY_SECRET!)
      .update(`${orderId}|${paymentId}`)
      .digest('hex');

    if (generatedSignature !== signature) {
      logger.error(`[${requestId}] Invalid payment signature`);
      return res.status(400).json({ success: false, error: 'Invalid payment signature', requestId });
    }

    // Fetch payment details from Razorpay
    const payment = await withRetry(() => razorpay.payments.fetch(paymentId));
    if (payment.status !== 'captured') {
      logger.error(`[${requestId}] Payment not captured`, { paymentId, status: payment.status });
      return res.status(400).json({ success: false, error: 'Payment not captured', requestId });
    }

    // Verify order exists and belongs to user
    const order = await prisma.order.findUnique({
      where: { id: dbOrderId },
      select: { userId: true, status: true },
    });

    if (!order) {
      logger.error(`[${requestId}] Order not found`, { dbOrderId });
      return res.status(404).json({ success: false, error: 'Order not found', requestId });
    }

    if (order.userId !== userId) {
      logger.error(`[${requestId}] Unauthorized access to order`, { dbOrderId, userId });
      return res.status(403).json({ success: false, error: 'Not authorized to verify this order', requestId });
    }

    if (order.status !== 'pending') {
      logger.error(`[${requestId}] Order already processed`, { dbOrderId, status: order.status });
      return res.status(400).json({ success: false, error: 'Order already processed', requestId });
    }

    // Call confirmOrder to finalize the order
    await confirmOrder(
      { ...req, body: { dbOrderId, paymentId } } as AuthRequest,
      res,
      () => {}
    );

    logger.info(`[${requestId}] Payment verified successfully`, { paymentId, dbOrderId, userId });
    return res.json({
      success: true,
      message: 'Payment verified and order confirmed',
      requestId,
    });
  } catch (err: any) {
    logger.error(`[${requestId}] Verify payment error`, {
      message: err.message,
      stack: err.stack,
      userId: req.user?.id,
      requestBody: req.body,
    });
    return res.status(500).json({
      success: false,
      error: err instanceof z.ZodError
        ? err.errors.map((e) => e.message).join(', ')
        : 'Failed to verify payment',
      requestId,
    });
  }
};
then i have productController.ts file
import { Response } from 'express';
import { AsyncRequestHandler, AuthRequest } from '../types/custom';
import prisma from '../prisma/client';
import { z } from 'zod';
import { ValidationError, ForbiddenError, NotFoundError, AppError } from '../utils/errorHandler';
import { logger } from '../utils/logger';
// import { isValidObjectId } from 'mongoose';

// Simple ObjectId validation (24 hex chars) or adjust as per your ID format
function isValidObjectId(id: string): boolean {
  return /^[a-f\d]{24}$/i.test(id);
}

// Schema for creating a product
const createProductSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  category: z.string().min(1, 'Category is required'),
  price: z.number().positive('Price must be positive'),
  mrp: z.number().positive('MRP must be positive').optional().nullable(),
  images: z.array(z.string().url()).min(1, 'At least one image URL is required'),
  colors: z.array(z.string()).optional(),
  sizes: z.array(z.string()).optional(),
  quantity: z.number().int().nonnegative('Quantity must be non-negative'),
  description: z.string().default(''),
  stockBySize: z.record(z.number().int().nonnegative()).optional(),
});

// Schema for updating a product
const updateProductSchema = z.object({
  name: z.string().min(1, 'Name cannot be empty').optional(),
  category: z.string().min(1, 'Category cannot be empty').optional(),
  price: z.number().positive('Price must be positive').optional(),
  mrp: z.number().positive('MRP must be positive').optional().nullable(),
  images: z.array(z.string().url()).min(1, 'At least one image URL is required').optional(),
  colors: z.array(z.string()).optional(),
  sizes: z.array(z.string()).optional(),
  quantity: z.number().int().nonnegative('Quantity must be non-negative').optional(),
  description: z.string().optional(),
  stockBySize: z.record(z.number().int().nonnegative()).optional(),
});

// Fetch all products with optional category filter
export const getProducts: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = req.headers['x-request-id'] as string;
  const { category } = req.query;

  try {
    const products = await prisma.product.findMany({
      where: category ? { category: String(category) } : undefined,
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        mrp: true,
        images: true,
        category: true,
        colors: true,
        sizes: true,
        quantity: true,
        stockBySize: true,
        createdAt: true,
        updatedAt: true,
      },
    });
    logger.info(`[${requestId}] Fetched ${products.length} products`, { category });
    return res.status(200).json({ success: true, data: products, requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Get products error`, {
      message: error.message,
      stack: error.stack,
      category,
    });
    throw new AppError('Failed to fetch products', 500);
  }
};

// Fetch a product by ID
export const getProductById: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = req.headers['x-request-id'] as string;
  const { id } = req.params;

  try {
    if (!id) {
      throw new ValidationError('Product ID is required');
    }

    if (!isValidObjectId(id)) {
      throw new ValidationError('Invalid Product ID format');
    }

    const product = await prisma.product.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        mrp: true,
        images: true,
        category: true,
        colors: true,
        sizes: true,
        quantity: true,
        stockBySize: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!product) {
      throw new NotFoundError('Product not found');
    }

    logger.info(`[${requestId}] Fetched product ${id}`);
    return res.status(200).json({ success: true, data: product, requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Get product by ID error`, {
      message: error.message,
      stack: error.stack,
      productId: id,
    });
    throw error;
  }
};

// Create a new product
export const createProduct: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = req.headers['x-request-id'] as string;

  try {
    if (!req.user || req.user.role !== 'admin') {
      throw new ForbiddenError('Admin access required');
    }

    const data = createProductSchema.parse(req.body);

    if (data.sizes && data.sizes.length > 0 && data.stockBySize) {
      const totalStock = Object.values(data.stockBySize).reduce((sum, val) => sum + val, 0);
      if (totalStock !== data.quantity) {
        throw new ValidationError('Total stockBySize must equal quantity');
      }
    }

    const newProduct = await prisma.product.create({
      data: {
        ...data,
        colors: data.colors || ['#000000', '#FF0000', '#00FF00'],
        sizes: data.sizes || ['S', 'M', 'L', 'XL'],
        stockBySize: data.stockBySize || {},
      },
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        mrp: true,
        images: true,
        category: true,
        colors: true,
        sizes: true,
        quantity: true,
        stockBySize: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    logger.info(`[${requestId}] Created product ${newProduct.id}`, { name: data.name });
    return res.status(201).json({ success: true, data: newProduct, requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Create product error`, {
      message: error.message,
      stack: error.stack,
      requestBody: req.body,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

// Update an existing product
export const updateProduct: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = req.headers['x-request-id'] as string;
  const { id } = req.params;

  try {
    if (!req.user || req.user.role !== 'admin') {
      throw new ForbiddenError('Admin access required');
    }

    if (!id) {
      throw new ValidationError('Product ID is required');
    }

    if (!isValidObjectId(id)) {
      throw new ValidationError('Invalid Product ID format');
    }

    const data = updateProductSchema.parse(req.body);

    if (data.sizes && data.quantity && data.stockBySize) {
      const totalStock = Object.values(data.stockBySize).reduce((sum, val) => sum + val, 0);
      if (totalStock !== data.quantity) {
        throw new ValidationError('Total stockBySize must equal quantity');
      }
    }

    const product = await prisma.product.update({
      where: { id },
      data: {
        ...data,
        stockBySize: data.stockBySize || undefined,
      },
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        mrp: true,
        images: true,
        category: true,
        colors: true,
        sizes: true,
        quantity: true,
        stockBySize: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    logger.info(`[${requestId}] Updated product ${id}`, { name: data.name });
    return res.status(200).json({ success: true, data: product, requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Update product error`, {
      message: error.message,
      stack: error.stack,
      productId: id,
      requestBody: req.body,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

// Delete a product
export const deleteProduct: AsyncRequestHandler = async (req: AuthRequest, res: Response): Promise<Response | void> => {
  const requestId = req.headers['x-request-id'] as string;
  const { id } = req.params;

  try {
    if (!req.user || req.user.role !== 'admin') {
      throw new ForbiddenError('Admin access required');
    }

    if (!id) {
      throw new ValidationError('Product ID is required');
    }

    if (!isValidObjectId(id)) {
      throw new ValidationError('Invalid Product ID format');
    }

    const product = await prisma.product.findUnique({
      where: { id },
      select: { id: true },
    });

    if (!product) {
      throw new NotFoundError('Product not found');
    }

    await prisma.product.delete({
      where: { id },
    });

    logger.info(`[${requestId}] Deleted product ${id}`);
    return res.status(200).json({ success: true, message: 'Product deleted successfully', requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Delete product error`, {
      message: error.message,
      stack: error.stack,
      productId: id,
    });
    throw error;
  }
};
then i have reviewController.ts file
// backend/controllers/reviewController.ts
import { Response } from 'express';
import { AsyncRequestHandler, AuthRequest } from '../types/custom';
import prisma from '../prisma/client';
import { z } from 'zod';
import { ValidationError } from '../utils/errorHandler';
import { logger } from '../utils/logger';

const reviewSchema = z.object({
  productId: z.string().min(1, 'Product ID is required'),
  rating: z.number().int().min(1, 'Rating must be at least 1').max(5, 'Rating cannot exceed 5'),
  comment: z.string().min(1, 'Comment is required'),
});

export const submitReview: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  const requestId = req.headers['x-request-id'] as string;
  try {
    const { productId, rating, comment } = reviewSchema.parse(req.body);
    const userId = req.user?.id;

    if (!userId) {
      throw new ValidationError('User not authenticated');
    }

    const product = await prisma.product.findUnique({ where: { id: productId } });
    if (!product) {
      throw new ValidationError('Product not found');
    }

    const review = await prisma.review.create({
      data: {
        productId,
        userId,
        rating,
        comment,
      },
    });

    logger.info(`[${requestId}] Review submitted for product ${productId}`, { userId, rating });
    return res.status(201).json({ success: true, data: review, requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Submit review error`, {
      message: error.message,
      stack: error.stack,
      requestBody: req.body,
    });
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors.map((e) => e.message).join(', '));
    }
    throw error;
  }
};

export const getReviews: AsyncRequestHandler = async (req: AuthRequest, res: Response) => {
  const requestId = req.headers['x-request-id'] as string;
  const { productId } = req.params;

  try {
    if (!productId) {
      throw new ValidationError('Product ID is required');
    }

    const reviews = await prisma.review.findMany({
      where: { productId },
      include: { user: { select: { name: true } } },
      orderBy: { createdAt: 'desc' },
    });

    logger.info(`[${requestId}] Fetched ${reviews.length} reviews for product ${productId}`);
    return res.status(200).json({ success: true, data: reviews, requestId });
  } catch (error: any) {
    logger.error(`[${requestId}] Get reviews error`, {
      message: error.message,
      stack: error.stack,
      productId,
    });
    throw error;
  }
};
then i have middleware folder in that i have adminOnly.ts file
import { Response, NextFunction } from 'express';
import { AuthRequest } from '../types/custom';
import { asyncHandler } from '../utils/asyncHandler';

export const adminOnly = asyncHandler(async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({
      success: false,
      error: 'Access denied. Admin role required.',
    });
  }
  next();
});

then i have auth.ts file
import { Response, NextFunction } from 'express';
import { AuthRequest } from '../types/custom';
import jwt from 'jsonwebtoken';
import prisma from '../prisma/client';
import { asyncHandler } from '../utils/asyncHandler';

export const authenticate = asyncHandler(async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.cookies.jwt;
  if (!token) {
    return res.status(401).json({ success: false, error: 'No token provided' });
  }

  if (!process.env.JWT_SECRET) {
    return res.status(500).json({ success: false, error: 'JWT secret not configured' });
  }

  const decoded = jwt.verify(token, process.env.JWT_SECRET) as {
    id: string;
    email: string;
    role: string;
    name?: string;
  };

  const user = await prisma.user.findUnique({
    where: { id: decoded.id },
    select: { id: true, email: true, role: true, name: true }
  });

  if (!user) {
    return res.status(401).json({ success: false, error: 'User not found' });
  }

  req.user = {
    id: user.id,
    email: user.email,
    role: user.role,
    name: user.name || undefined
  };

  next();
});

export const isAdmin = asyncHandler(async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ 
      success: false, 
      error: 'Admin access required' 
    });
  }
  next();
});
then i have prisma folder in that i have client.ts file
// backend/prisma/client.ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient({
  log: ["query", "info", "warn", "error"], // Optional: Enable query logging for debugging
});

export default prisma;
then i have schema.prisma file
// schema.prisma

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "./node_modules/@prisma/client"
}

model User {
  id                 String             @id @default(auto()) @map("_id") @db.ObjectId
  email              String             @unique
  password           String
  name               String?
  role               String             @default("user")
  reviews            Review[]
  orders             Order[]
  usedOfferCodes     UserOfferCode[]
  securityQuestions  SecurityQuestion[]
  cart               Cart?              @relation("UserCart")
  cartId             String?            @db.ObjectId
  isVerified         Boolean            @default(false)
  verificationToken  String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
}

model Product {
  id             String              @id @default(auto()) @map("_id") @db.ObjectId
  name           String
  description    String
  price          Float
  mrp            Float?
  images         String[]            @default(["https://res.cloudinary.com/dugh8szaj/image/upload/v1744894443/bag1_jtaqsb.avif"])
  category       String
  colors         String[]            @default(["#000000", "#FF0000", "#00FF00"])
  sizes          String[]            @default(["S", "M", "L", "XL"])
  rating         Float?              @default(4.5)
  reviewCount    Int                 @default(35142)
  reviews        Review[]
  deliveryInfo   String?             @default("FREE delivery Fri, 18 Apr or fastest Tomorrow, 17 Apr")
  quantity       Int                 @default(0)
  stockBySize    Json?
  dimensions     Json?
  weight         Float?
  orderCount     Int                 @default(0)
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  orderItems     OrderItem[]
  offerCodes     ProductOfferCode[]
  cartItems      CartItem[]
  version        Int                 @default(0)
}

model Order {
  id               String        @id @default(auto()) @map("_id") @db.ObjectId
  userId           String        @db.ObjectId
  user             User          @relation(fields: [userId], references: [id])
  orderItems       OrderItem[]
  totalAmount      Float
  status           String        @default("pending")
  paymentId        String?
  shiprocketOrderId String?
  trackingUrl      String?
  offerCode        String?
  discount         Float?
  shippingDetails  Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

model OrderItem {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  orderId    String   @db.ObjectId
  productId  String   @db.ObjectId
  order      Order    @relation(fields: [orderId], references: [id])
  product    Product  @relation(fields: [productId], references: [id])
  quantity   Int
  size       String?
  price      Float
}

model OfferCode {
  id              String              @id @default(auto()) @map("_id") @db.ObjectId
  code            String              @unique
  discount        Int
  isFirstOrder    Boolean
  expiryDate      DateTime?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  userOfferCodes  UserOfferCode[]
  products        ProductOfferCode[]
}

model UserOfferCode {
  id           String     @id @default(auto()) @map("_id") @db.ObjectId
  userId       String     @db.ObjectId
  offerCodeId  String     @db.ObjectId
  user         User       @relation(fields: [userId], references: [id])
  offerCode    OfferCode  @relation(fields: [offerCodeId], references: [id])
  usedAt       DateTime   @default(now())
}

model ProductOfferCode {
  id           String     @id @default(auto()) @map("_id") @db.ObjectId
  productId    String     @db.ObjectId
  offerCodeId  String     @db.ObjectId
  product      Product    @relation(fields: [productId], references: [id])
  offerCode    OfferCode  @relation(fields: [offerCodeId], references: [id])
  createdAt    DateTime   @default(now())
}

model Settings {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  storeName String
  currency  String
  updatedAt DateTime @updatedAt
}

model SecurityQuestion {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
  question  String
  answer    String
  createdAt DateTime @default(now())
}

model OTP {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  email      String
  otp        String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
}

model Cart {
  id         String     @id @default(auto()) @map("_id") @db.ObjectId
  userId     String     @db.ObjectId @unique
  user       User       @relation("UserCart", fields: [userId], references: [id])
  items      CartItem[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
}

model CartItem {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  cartId     String    @db.ObjectId
  productId  String    @db.ObjectId
  cart       Cart      @relation(fields: [cartId], references: [id])
  product    Product   @relation(fields: [productId], references: [id])
  quantity   Int
  price      Float
  size       String?
  createdAt  DateTime  @default(now())
}

model BlacklistedToken {
  id         String   @id @default(uuid()) @map("_id")
  token      String   @unique
  createdAt  DateTime @default(now())
  expiresAt  DateTime?
}

model OtpRequest {
  id        String   @id @default(uuid()) @map("_id")
  email     String
  createdAt DateTime @default(now())
}

model Review {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  productId String   @db.ObjectId
  userId    String   @db.ObjectId
  product   Product  @relation(fields: [productId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  rating    Int
  comment   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

then i have routes folder in that i have authRoutes.ts file
// backend/routes/authRoutes.ts
import express from 'express';
import { register, login, logout, resetPassword, requestResetOtp, verifyEmail, } from '../controllers/authController';
import { authenticate } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';
import rateLimit from 'express-rate-limit';

const router = express.Router();

// Rate limiters
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Limit to 10 login attempts per window per IP
  message: {
    success: false,
    error: 'Too many login attempts. Please try again after 15 minutes.',
  },
});

const otpRequestLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 3, // Limit to 3 OTP requests per window per IP
  message: {
    success: false,
    error: 'Too many OTP requests. Please try again after 15 minutes.',
  },
});

router.post('/register', asyncHandler(register));
router.post('/login', loginLimiter, asyncHandler(login));
router.post('/logout', authenticate, asyncHandler(logout));
router.post('/reset-password', asyncHandler(resetPassword));
router.post('/request-reset-otp', otpRequestLimiter, asyncHandler(requestResetOtp));
router.post('/verify-email', asyncHandler(verifyEmail)); // Add this line

export default router;
then i have cartRoutes.ts file
import express from 'express';
import { getCart, addToCart, updateCartItem, removeCartItem, clearCart, validateCart, syncCart } from '../controllers/cartController';
import { authenticate } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';

const router = express.Router();

router.get('/', authenticate, asyncHandler(getCart));
router.post('/sync', authenticate, asyncHandler(syncCart));
router.post('/add', authenticate, asyncHandler(addToCart));
router.put('/update', authenticate, asyncHandler(updateCartItem));
router.delete('/remove', authenticate, asyncHandler(removeCartItem));
router.delete('/clear', authenticate, asyncHandler(clearCart));
router.post('/validate', authenticate, asyncHandler(validateCart));

export default router;
then i have offerRoutes.ts file
import express from 'express';
import { applyOfferCode } from '../controllers/offerCode.controller';
import { authenticate } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';

const router = express.Router();

router.post('/apply', authenticate, asyncHandler(applyOfferCode));

export default router;
then i have orderRoutes.ts file
import express from 'express';
import { confirmOrder, getOrderTracking, getAllOrders } from '../controllers/orderController';
import { authenticate, isAdmin } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';

const router = express.Router();

router.post('/confirm', authenticate, asyncHandler(confirmOrder));
router.get('/track/:orderId', authenticate, asyncHandler(getOrderTracking));
router.get('/', authenticate, isAdmin, asyncHandler(getAllOrders));

export default router;
then i have paymentRoutes.ts file
// backend/routes/paymentRoutes.ts
import express from 'express';
import { createOrder, verifyPayment } from '../controllers/paymentController';
import { authenticate } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';

const router = express.Router();

router.post('/create', authenticate, asyncHandler(createOrder));
router.post('/verify', authenticate, asyncHandler(verifyPayment));

export default router;
then i have productRoutes.ts file
import express from 'express';
import {
  getProducts,
  createProduct,
  updateProduct,
  deleteProduct,
  getProductById,
} from '../controllers/productController';
import { authenticate, isAdmin } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';
import rateLimit from 'express-rate-limit';
import prisma from '../prisma/client'; // Import Prisma client

const router = express.Router();

const adminOperationLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 50, // Limit to 50 requests per window per IP
  message: {
    success: false,
    error: 'Too many requests. Please try again later.',
  },
});

router.get('/', asyncHandler(getProducts));
router.get('/categories', async (req, res) => {
  try {
    const categories = await prisma.product.findMany({
      distinct: ['category'],
      select: { category: true },
    });
    const categoryList = categories.map((item) => item.category);
    res.json({ success: true, data: categoryList });
  } catch (error) {
    console.error('Error fetching categories:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch categories' });
  }
});
router.get('/:id', asyncHandler(getProductById));
router.post('/', authenticate, isAdmin, adminOperationLimiter, asyncHandler(createProduct));
router.put('/:id', authenticate, isAdmin, adminOperationLimiter, asyncHandler(updateProduct));
router.delete('/:id', authenticate, isAdmin, adminOperationLimiter, asyncHandler(deleteProduct));

export default router;
then i have src\config folder in that i have cloudinary.ts file
// backend/src/config/cloudinary.ts
import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export default cloudinary;
then i have utils folder in that i have 
asyncHandler.ts file
import { Request, Response, NextFunction } from 'express';
import { AppError } from './errorHandler';

export const asyncHandler = (
  fn: (req: Request, res: Response, next: NextFunction) => Promise<any>
) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch((err) => {
      if (!(err instanceof AppError)) {
        err = new AppError(err.message || 'Internal Server Error', 500);
      }
      next(err);
    });
  };
};
then i have emailUtils.ts file
import { Resend } from 'resend';
import { logger } from './logger';

const resend = new Resend(process.env.RESEND_API_KEY);

export const sendVerificationEmail = async (email: string, token: string): Promise<void> => {
  const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${token}`;
  
  try {
    await resend.emails.send({
      from: process.env.RESEND_FROM_EMAIL || 'no-reply@yourdomain.com',
      to: email,
      subject: 'Verify Your Email Address',
      html: `
        <h2>Welcome to Our E-commerce Platform!</h2>
        <p>Please verify your email address by clicking the link below:</p>
        <a href="${verificationUrl}" style="padding: 10px 20px; background-color: #007bff; color: #fff; text-decoration: none; border-radius: 5px;">Verify Email</a>
        <p>If the button doesn't work, copy and paste this link into your browser:</p>
        <p>${verificationUrl}</p>
        <p>This link will expire in 24 hours.</p>
      `,
    });
  } catch (error: any) {
    logger.error('Failed to send verification email', {
      message: error.message,
      stack: error.stack,
      email,
    });
    throw new Error('Failed to send verification email');
  }
};
then i have errorHandler.ts file
import { z } from 'zod';
import { logger } from './logger';

export class AppError extends Error {
  public statusCode: number;
  public isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400);
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string) {
    super(message, 401);
  }
}

export class AccountLockoutError extends AppError {
  constructor(message: string) {
    super(message, 423);
  }
}

export const handleAuthError = (error: any, requestId: string): AppError => {
  if (error instanceof z.ZodError) {
    return new ValidationError(error.errors.map((e: z.ZodIssue) => e.message).join(', '));
  }
  
  if (error instanceof AuthenticationError || 
      error instanceof AccountLockoutError || 
      error instanceof ValidationError) {
    return error;
  }

  logger.error(`[${requestId}] Unhandled auth error:`, {
    message: error.message,
    stack: error.stack
  });
  return new AppError('An unexpected error occurred', 500);
};

export class ForbiddenError extends AppError {
  constructor(message: string) {
    super(message, 403);
  }
}

export class NotFoundError extends AppError {
  constructor(message: string) {
    super(message, 404);
  }
}

import { Request, Response, NextFunction } from 'express';

export const errorMiddleware = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      success: false,
      error: err.message,
      requestId: req.headers['x-request-id'],
    });
  }

  console.error('Unexpected error:', {
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
  });

  res.status(500).json({
    success: false,
    error: 'Internal Server Error',
    requestId: req.headers['x-request-id'],
  });
};
then i have logger.ts file
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ],
});
then i have otpUtils.ts file
import prisma from '../prisma/client';

// Generates a 6-digit OTP
export function generateOtp(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

// Validates OTP format (6 digits)
export function validateOtp(email: string, otp: string): Promise<boolean> {
  return prisma.oTP.findFirst({
    where: {
      email,
      otp,
      expiresAt: { gte: new Date() },
    },
  }).then((result) => !!result);
}

// Saves OTP to the database
export async function saveOTP(email: string, otp: string, expiresInMinutes: number = 5): Promise<void> {
  const expiresAt = new Date(Date.now() + expiresInMinutes * 60 * 1000);
  await prisma.oTP.create({
    data: { email, otp, expiresAt },
  });
}
then i have shiprocket.ts file
import axios, { AxiosError } from 'axios';

const SHIPROCKET_API = 'https://apiv2.shiprocket.in/v1/external';

let shiprocketToken: { token: string; expiresAt: number } | null = null;

export const getShiprocketToken = async (): Promise<string> => {
  if (shiprocketToken && shiprocketToken.expiresAt > Date.now()) {
    return shiprocketToken.token;
  }

  try {
    const response = await axios.post(`${SHIPROCKET_API}/auth/login`, {
      email: process.env.SHIPROCKET_EMAIL,
      password: process.env.SHIPROCKET_PASSWORD,
    });

    shiprocketToken = {
      token: response.data.token,
      expiresAt: Date.now() + 24 * 60 * 60 * 1000, // Assume 24 hours validity
    };

    console.log('Shiprocket token fetched');
    return shiprocketToken.token;
  } catch (error) {
    console.error('Shiprocket login failed:', error);
    throw new Error('Unable to authenticate with Shiprocket');
  }
};

export const createShiprocketOrder = async (orderData: any, retries = 3): Promise<any> => {
  const token = await getShiprocketToken();
  try {
    const response = await axios.post(`${SHIPROCKET_API}/orders/create/adhoc`, orderData, {
      headers: { Authorization: `Bearer ${token}` },
    });
    console.log('Shiprocket order created:', response.data.order_id);
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 429 && retries > 0) {
      console.warn(`Rate limit hit, retrying in 1s... (${retries} attempts left)`);
      await new Promise((resolve) => setTimeout(resolve, 1000));
      return createShiprocketOrder(orderData, retries - 1);
    }
    console.error('Shiprocket order creation failed:', error);
    throw new Error('Unable to create Shiprocket order');
  }
};

export const getTrackingInfo = async (orderId: string, retries = 3): Promise<any> => {
  const token = await getShiprocketToken();
  try {
    const response = await axios.get(`${SHIPROCKET_API}/orders/track?order_id=${orderId}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    console.log(`Fetched tracking for Shiprocket order ${orderId}`);
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 429 && retries > 0) {
      console.warn(`Rate limit hit, retrying in 1s... (${retries} attempts left)`);
      await new Promise((resolve) => setTimeout(resolve, 1000));
      return getTrackingInfo(orderId, retries - 1);
    }
    console.error('Shiprocket tracking failed:', error);
    throw new Error('Unable to fetch tracking info');
  }
};
then i have validation.ts file
export function validateEmail(email: string): boolean {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}

export function validatePassword(password: string): boolean {
  const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return regex.test(password);
}

export function validateName(name: string): boolean {
  const regex = /^[a-zA-Z\s]{2,50}$/;
  return regex.test(name);
}

export function validatePhone(phone: string): boolean {
  const regex = /^\d{10}$/;
  return regex.test(phone);
}

export function validatePincode(pincode: string): boolean {
  const regex = /^\d{6}$/;
  return regex.test(pincode);
}
then i have validationSchemas.ts file
import { z } from 'zod';
import { validateEmail, validatePassword, validateName } from './validation';

export const registerSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .refine((email) => validateEmail(email), {
      message: 'Invalid email format',
    }),
  password: z
    .string()
    .min(1, 'Password is required')
    .refine((password) => validatePassword(password), {
      message:
        'Password must be at least 8 characters long, include an uppercase letter, a lowercase letter, a number, and a special character',
    }),
  name: z
    .string()
    .min(1, 'Name is required')
    .refine((name) => validateName(name), {
      message: 'Name must be 2-50 characters long and contain only letters and spaces',
    }),
  securityQuestions: z
    .array(
      z.object({
        question: z.string().min(1, 'Security question is required'),
        answer: z.string().min(1, 'Security answer is required'),
      })
    )
    .optional(),
});

export const loginSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .refine((email) => validateEmail(email), {
      message: 'Invalid email format',
    }),
  password: z.string().min(1, 'Password is required'),
});

export const resetPasswordSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .refine((email) => validateEmail(email), {
      message: 'Invalid email format',
    }),
  otp: z.string().min(1, 'OTP is required'),
  newPassword: z
    .string()
    .min(1, 'New password is required')
    .refine((password) => validatePassword(password), {
      message:
        'New password must be at least 8 characters long, include an uppercase letter, a lowercase letter, a number, and a special character',
    }),
});

export const requestOtpSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .refine((email) => validateEmail(email), {
      message: 'Invalid email format',
    }),
});
then i have .env file
RAZORPAY_KEY_ID=rzp_test_UiTkSmK6mjclhU
RAZORPAY_KEY_SECRET=IANiniLncZfln7WWjWbr6mbx
DATABASE_URL="mongodb+srv://new:new@ecom.oa5c1i2.mongodb.net/new?retryWrites=true&w=majority&appName=Ecommerce&maxPoolSize=50"
PORT=5000
JWT_SECRET=e86b91235381a73179aa261a3e4edf2b39bb977333b7098ab8dd41e3faa3c2d0cf8a828f77f2fef51e3d8749500d43633cffa52ea424d00698abc6b09f30f7ea
SHIPROCKET_EMAIL=Bharat.tejwani23012001@gmail.com
SHIPROCKET_PASSWORD=Bharat2301@
CLOUDINARY_CLOUD_NAME=dugh8szaj
CLOUDINARY_API_KEY=659382545759118
CLOUDINARY_API_SECRET=LjRo7ZgTpOaAEWossDy8paLzyTw
CLOUDINARY_UPLOAD_PRESET=ecommerce_unsigned
RESEND_API_KEY=re_HBfnfdAN_9aLkmTMcUMkowJn8WkbXHd1Q
FRONTEND_URL=http://localhost:3000
RESEND_FROM_EMAIL="noreply@myecomapp.com"
OTP_EXPIRY_MINUTES=5
then i have seed.ts file
import prisma from './prisma/client';
import bcrypt from 'bcrypt';

async function seed() {
  try {
    console.log('Hashing passwords...');
    const hashedAdminPassword = await bcrypt.hash('admin123', 10);
    const hashedUserPassword = await bcrypt.hash('user123', 10);

    console.log('Deleting existing data...');
    await prisma.userOfferCode.deleteMany();
    await prisma.orderItem.deleteMany();
    await prisma.order.deleteMany();
    await prisma.offerCode.deleteMany();
    await prisma.cartItem.deleteMany();
    await prisma.cart.deleteMany();
    await prisma.product.deleteMany();
    await prisma.user.deleteMany();
    await prisma.securityQuestion.deleteMany();
    await prisma.oTP.deleteMany();

    console.log('Seeding admin and user...');
    const admin = await prisma.user.create({
      data: {
        email: 'admin@example.com',
        password: hashedAdminPassword,
        name: 'Admin User',
        role: 'admin',
        securityQuestions: {
          create: [
            { question: 'What is your pet’s name?', answer: 'Max' },
            { question: 'What is your mother’s maiden name?', answer: 'Smith' },
          ],
        },
      },
    });

    const user = await prisma.user.create({
      data: {
        email: 'user@example.com',
        password: hashedUserPassword,
        name: 'Test User',
        role: 'user',
        securityQuestions: {
          create: [
            { question: 'What is your pet’s name?', answer: 'Buddy' },
            { question: 'What is your mother’s maiden name?', answer: 'Jones' },
          ],
        },
      },
    });

    console.log('Seeding products...');
    await prisma.product.createMany({
      data: [
        {
          name: 'T-Shirt',
          description: 'Comfortable cotton t-shirt',
          price: 599,
          mrp: 799,
          images: ['https://res.cloudinary.com/dugh8szaj/image/upload/v1744894443/tshirt1.jpg'],
          category: 'Clothing',
          colors: ['#000000', '#FFFFFF'],
          sizes: ['S', 'M', 'L'],
          quantity: 100,
          stockBySize: { S: 30, M: 40, L: 30 },
        },
        {
          name: 'Jeans',
          description: 'Slim fit denim jeans',
          price: 1299,
          mrp: 1599,
          images: ['https://res.cloudinary.com/dugh8szaj/image/upload/v1744894443/jeans1.jpg'],
          category: 'Clothing',
          colors: ['#0000FF'],
          sizes: ['30', '32', '34'],
          quantity: 90,
          stockBySize: { '30': 20, '32': 40, '34': 30 },
        },
      ],
    });

    console.log('Seeding offer codes...');
    await prisma.offerCode.createMany({
      data: [
        {
          code: 'FIRST20',
          discount: 20,
          isFirstOrder: true,
          expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        },
        {
          code: 'NEXT10',
          discount: 10,
          isFirstOrder: false,
          expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        },
      ],
    });

    console.log('✅ Database seeded successfully!');
    console.log('Admin Credentials: admin@example.com / admin123');
    console.log('User Credentials: user@example.com / user123');
  } catch (error) {
    console.error('❌ Error seeding database:', error);
  } finally {
    await prisma.$disconnect();
  }
}

seed();
export default seed;
then i have server.ts file
// backend/server.ts
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import prisma from './prisma/client';
import authRoutes from './routes/authRoutes';
import productRoutes from './routes/productRoutes';
import paymentRoutes from './routes/paymentRoutes';
import orderRoutes from './routes/orderRoutes';
import offerRoutes from './routes/offerRoutes';
import cartRoutes from './routes/cartRoutes';
import { errorMiddleware } from './utils/errorHandler';
import { logger } from './utils/logger';
import { v4 as uuidv4 } from 'uuid';

dotenv.config();

const app: Application = express();
const PORT = process.env.PORT || 5000;

// Validate required environment variables
const requiredEnvVars = [
  'DATABASE_URL',
  'JWT_SECRET',
  'RAZORPAY_KEY_ID',
  'RAZORPAY_KEY_SECRET',
  'SHIPROCKET_EMAIL',
  'SHIPROCKET_PASSWORD',
  'RESEND_API_KEY',
  'CLOUDINARY_CLOUD_NAME',
  'CLOUDINARY_API_KEY',
  'CLOUDINARY_API_SECRET',
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    logger.error(`Missing required environment variable: ${envVar}`);
    process.exit(1);
  }
}

// Middleware
app.use(helmet());
app.use(
  cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true,
  })
);
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Request ID middleware
app.use((req: Request, res: Response, next: NextFunction) => {
  const requestId = uuidv4();
  req.headers['x-request-id'] = requestId;
  logger.info(`Request started`, {
    method: req.method,
    path: req.path,
    requestId,
  });
  next();
});

// Health check endpoint
app.get('/api/health', (req: Request, res: Response) => {
  res.status(200).json({ status: 'healthy', requestId: req.headers['x-request-id'] });
});

// Mount routes
app.use('/api/auth', authRoutes);
app.use('/api/products', productRoutes);
app.use('/api/payments', paymentRoutes);
app.use('/api/orders', orderRoutes);
app.use('/api/offers', offerRoutes);
app.use('/api/cart', cartRoutes);

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({
    success: false,
    error: 'Not Found',
    requestId: req.headers['x-request-id'],
  });
});

// Error handler
app.use(errorMiddleware as (err: any, req: Request, res: Response, next: NextFunction) => void);

// Start server
const server = app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received. Shutting down gracefully');
  server.close(async () => {
    await prisma.$disconnect();
    logger.info('Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  logger.info('SIGINT received. Shutting down gracefully');
  server.close(async () => {
    await prisma.$disconnect();
    logger.info('Server closed');
    process.exit(0);
  });
});

export default app;